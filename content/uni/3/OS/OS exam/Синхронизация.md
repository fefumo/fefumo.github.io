#uni 
#prog
# Основные примитивы синхронизации:
- семафоры (захват и освобождение множественного ресурса)
- мьютексы (блокировка и освбождение ресурса единственным потоком или процессом)
- условные переменные (блокировка до выполнения какого-либо условия)
- блокировки чтения и записи
- мониторы (конструкции языков программирования, которые скрывают низкоуровневые примитивы синхронизации)
- флаги событий (связывание условий продолжения выполнения с одним или несколькими флагами)
- почтовые ящики (примтив передачи сообщений)
- спинлоки

### Семафоры и мьютексы
Семафоры - захват или освбождение множественного ресурса. Или одного (бинарные семафоры). _Блокирующий_ примитив.
Есть счетчик ресурса. Если ресурс занят, то потоки попадающие в очередь блокируются. Блокировка — очень ресурсозатратный процесс. Сначала переключить контекст при блокировании, потом обратно возвращаем при извлечении из очереди. Используется для счётных ресурсов. Например, параллельное чтение или пул работников workes

Мьютексы - блокировка и освобождение ресурса единственным потоком/процессом. Обеспечивает взаимное исключение исполнения критических участков кода. `lock(), unlock()`.
Могут быть реализованы по разному: фьютексы, UserSpace мьютексы, которые стараются как можно меньше блокировать, потому что блокировка вызывает смену контекста ядра. 
Проблема: если поток с низким приоритетом захватил ресурс, пришедший поток с высоким приоритетом не сможет вытеснить низкий поток и занять ресурс, он также отправляется в очередь.

Еще есть спин-локи. _Циклическая_ блокировка. На уровне ядра они эквивалентны разновидности мьютекса. Применяются, когда ожидание захвата блокироваки предполагается недолгим, либо если контекст выполнения не позволяет переходить в заблокированное состояние.

### Условные переменные, rwlocks
Условные переменные — блокировка до выполнения какого-либо условия.
`wait(condition, lock);  signal(condition, lock); broadcast(condition, lock);`

rw-lock отдельные блокировки на чтение и запись. Основная задача: сделать так, чтобы много потоков могли одновременно читать, и только один писать. То есть когда ресурс не заблокирован, у него может быть произвольное кол-во читателей. Но когда кому-то что-то захочется записать, то он посылает сигнал на запись, и ждет, когда все читатели уйдут с ресурса. Как только это наступает, на запись допускается один писатель и по завершению посылает всем сигнал, что ресурс снова свободен на чтение.

Существует проблема “гремящего стада” — когда ресурс освобождается (дается разрешение на запись), в все потоки хотят максимально быстро захватить этот ресурс, кто первый успел, тот молодец (погоня за ресурсом).

### Мониторы, флаги событий, передача событий
Мониторы — конструкции ЯП, которые скрывают низкоуровневые примитивы синхронизации. Например, в java есть ключевое слово synchornized.
Плюсы: это просто 
Минсы: программист может не понимать всю суть работы этого методы и пихать их везде, где захочется, а переизбыток будет тормозить систему. Эффективнее использовать более низкоуровневые примитивы.

Флаги событий — связывание условий продолжения выполнения с одним или несколькими флагами (битами блокирующей переменной). Является редким примитивом блокировки, используется в старых системах, также есть в Python. Суть: кто-то ставит флаги (о вводе/выводе/готовности каких-то частей), другой поток может прочитать значение этих флагов и продолжить выполнение, если установлены определенные флаги.

Почтовые ящики – примтив передачи сообщений. высокоуровневый примитив, достаточно часто используется в очередях.
- Две операции send(получатель, сообщение) и recieve(отправитель, сообщение).
- Необходим метод адресации получателя и отправителя (прямая/косвенная адресация)
- Раздельная синхронизация посылки и получения
- Формат сообщения
- Выборки из очереди — приоритет, FIFO, …
### Неблокирующие примитивы и структуры данных синхронизации
> Блокировка вызывает переклчение контекста – долго (дорого)

Преимущество неблокирующих алгоритмов — в лучшей масштабируемости по кол-ву процессоров. К тому же, если ОС прервёт один из потоков фоновой задачей, остальные, как минимум, выполнят свою работу, не простаивая. По максимуму — возьмут невыполненную работу на себя.

Типы неблокирующих алгоритмов
1. Wait-free (N-steps)(без ожиданий)
	1. Самая строгая гарантия прогресса. Алгоритм работает без ожиданий, если каждая операция выполняется за определенное количество шагов, не зависящее от других потоков
2. Lock-free
	1. Для алгоритмов без блокировок гарантируется системный прогресс по крайней мере одного потока. Например, поток, выполняющий операцию «[сравнение с обменом](https://ru.wikipedia.org/wiki/%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81_%D0%BE%D0%B1%D0%BC%D0%B5%D0%BD%D0%BE%D0%BC)» в цикле, теоретически может выполняться бесконечно, но каждая его итерация означает, что какой-то другой поток совершил прогресс, то есть система в целом совершает прогресс.
3. Obstruction free
	1. Самая слабая из гарантий. Поток совершает прогресс, если не встречает препятствий со стороны других потоков. Алгоритм работает без препятствий, если поток, запущенный в любой момент (при условии, что выполнение всех препятствующих потоков приостановлено) завершит свою работу за детерминированное количество шагов. Синхронизация с помощью мьютексов не отвечает даже этому требованию: если поток остановится, захватив мьютекс, то остальные потоки, которым этот мьютекс нужен, будут простаивать.
