---
tags:
  - uni
---
> rs - source register
> rd - destination register
> opcode - operation code
> funct - function fields

|  Type  |       Example Instructions       | Opcode (bin) | Opcode (hex) |            Notes            |
| :----: | :------------------------------: | :----------: | :----------: | :-------------------------: |
| R-type | add, sub, mul, div, and, or, xor |  `0110011`   |    `0x33`    |   ALU register operations   |
| I-type |         addi, andi, ori          |  `0010011`   |    `0x13`    |      ALU immediate ops      |
| I-type |              lw, lb              |  `0000011`   |    `0x03`    |      Load instructions      |
| I-type |               jalr               |  `1100111`   |    `0x67`    |        Indirect jump        |
| S-type |              sw, sb              |  `0100011`   |    `0x23`    |     Store instructions      |
| B-type |        beq, bne, blt, bge        |  `1100011`   |    `0x63`    |    Conditional branches     |
| U-type |               lui                |  `0110111`   |    `0x37`    |    Load upper immediate     |
| U-type |              auipc               |  `0010111`   |    `0x17`    | PC-relative upper immediate |
| J-type |               jal                |  `1101111`   |    `0x6F`    |  Unconditional jump + link  |
|  SYS   |               halt               |  `1111111`   |    `0x7F`    |     Custom system/halt      |
## new era

#### R-type инструкции

Формат:

|  funct7  |   rs2    |   rs1    |  funct3  |   rd    | opcode |
| :------: | :------: | :------: | :------: | :-----: | :----: |
| [31..25] | [24..20] | [19..15] | [14..12] | [11..7] | [6..0] |


Инструкции:

| Instruction | funct7  | funct3 | opcode (0x33) |    Description    |
| :---------: | :-----: | :----: | :-----------: | :---------------: |
|     add     | 0000000 |  000   |    0110011    | `rd = rs1 + rs2`  |
|     sub     | 0000000 |  001   |    0110011    | `rd = rs1 - rs2`  |
|     and     | 0000000 |  010   |    0110011    | `rd = rs1 & rs2`  |
|     or      | 0000000 |  011   |    0110011    | `rd = rs1 \| rs2` |
|     xor     | 0000000 |  100   |    0110011    | `rd = rs1 ^ rs2`  |
|     mul     | 0000000 |  101   |    0110011    | `rd = rs1 * rs2`  |
|     div     | 0000000 |  110   |    0110011    | `rd = rs1 / rs2`  |
|     lsl     | 0000000 |  111   |    0110011    | `rd = rs1 << rs2` |
|     lsr     | 0000001 |  000   |    0110011    | `rd = rs1 >> rs2` |

---

#### I-type инструкции

Формат:

| imm[11:0] |   rs1    |  funct3  |   rd    | opcode |
| :-------: | :------: | :------: | :-----: | :----: |
| [31..20]  | [19..15] | [14..12] | [11..7] | [6..0] |

Инструкции:

| Instruction | funct3 | opcode  |                   Description                    |
| :---------: | :----: | :-----: | :----------------------------------------------: |
|    addi     |  000   | 0010011 |                 `rd = rs1 + imm`                 |
|    andi     |  001   | 0010011 |                 `rd = rs1 & imm`                 |
|     ori     |  010   | 0010011 |                `rd = rs1 \| imm`                 |
|     lw      |  000   | 0000011 |   `rd = 32-bit word at mem[rs1 + offset]<br>`    |
|     lb      |  001   | 0000011 | ``rd ← sign-extended byte at mem[rs1 + offset]`` |
|    jalr     |  000   | 1100111 |            `PC = (rs1 + offset) & ~1`            |

---
#### S-type инструкции

Формат:

| imm[11:5] |   rs2    |   rs1    |  funct3  | imm[4:0] | opcode |
| :-------: | :------: | :------: | :------: | :------: | :----: |
| [31..25]  | [24..20] | [19..15] | [14..12] | [11..7]  | [6..0] |

Инструкции:

| Instruction | funct3 | opcode  |         Description          |
| :---------: | :----: | :-----: | :--------------------------: |
|     sw      |  000   | 0100011 |    `mem[rs1 + imm] = rs2`    |
|     sb      |  001   | 0100011 | `byte at mem[rs1+imm] = rs2` |

---
#### B-type инструкции

Формат:

| imm[12] | imm[10:5] |   rs2    |   rs1    |  funct3  | imm[4:1] | imm[11] | opcode |
| :-----: | :-------: | :------: | :------: | :------: | :------: | :-----: | :----: |
|  [31]   | [30..25]  | [24..20] | [19..15] | [14..12] | [11..8]  |   [7]   | [6..0] |


> После сборки все части immediate склеиваются обратно в 12-битный смещённый offset


Инструкции:

| Instruction | funct3 | opcode  |          Description          |
| :---------: | :----: | :-----: | :---------------------------: |
|     beq     |  000   | 1100011 | `if rs1 == rs2, PC += offset` |
|     bne     |  001   | 1100011 | `if rs1 != rs2, PC += offset` |
|     bgt     |  010   | 1100011 | `if rs1 > rs2, PC += offset`  |
|     ble     |  011   | 1100011 | `if rs1 <= rs2, PC += offset` |

---
#### U-type инструкции

Формат:

| imm[31:12] |   rd    | opcode |
| :--------: | :-----: | :----: |
|  [31..12]  | [11..7] | [6..0] |

Инструкции:

| Instruction | opcode  |   Description    |
| :---------: | :-----: | :--------------: |
|     lui     | 0110111 | `rd = imm << 12` |

---

#### J-type инструкции

Формат:

| imm[20] | imm[10:1] | imm[11] | imm[19:12] |   rd    | opcode |
| :-----: | :-------: | :-----: | :--------: | :-----: | :----: |
|  [31]   | [30..21]  |  [20]   |  [19..12]  | [11..7] | [6..0] |
> После склейки: `offset = {imm[20], imm[10:1], imm[11], imm[19:12]} << 1`

Инструкции:

| Instruction | opcode  |          Description          |
| :---------: | :-----: | :---------------------------: |
|     jal     | 1101111 | `rd = PC+4; PC = PC + offset` |

---
#### sys-type

Формат

| instruction | operands | opcode (bin) | opcode (hex) |    description     |
| :---------: | :------: | :----------: | :----------: | :----------------: |
|   `halt`    |    –     |  `1111111`   |    `0x7F`    | Custom system/halt |
## old era
### R-type инструкции
Формат:

|   funct7   |    rs2     |    rs1     |   funct3   |    rd     |  opcode  |
| :--------: | :--------: | :--------: | :--------: | :-------: | :------: |
| `[31..25]` | `[24..20]` | `[19..15]` | `[14..12]` | `[11..7]` | `[6..0]` |
|   7 bits   |   5 bits   |   5 bits   |   3 bits   |  5 bits   |  7 bits  |

Инструкции и их бинарное представление:

| Instruction |  funct7   | rs2 | rs1 | funct3 | rd  | opcode (`0x33`) |    description    |
| :---------: | :-------: | :-: | :-: | :----: | :-: | :-------------: | :---------------: |
|     add     | `0000000` |  -  |  -  | `000`  |  -  |    `0110011`    | `rd = rs1 + rs2`  |
|     sub     | `0000000` |  -  |  -  | `001`  |  -  |    `0110011`    | `rd = rs1 - rs2`  |
|     and     | `0000000` |  -  |  -  | `010`  |  -  |    `0110011`    | `rd = rs1 & rs2`  |
|     or      | `0000000` |  -  |  -  | `011`  |  -  |    `0110011`    | `rd = rs1 \| rs2` |
|     xor     | `0000000` |  -  |  -  | `100`  |  -  |    `0110011`    | `rd = rs1 ^ rs2`  |
|     mul     | `0000000` |  -  |  -  | `101`  |  -  |    `0110011`    | `rd = rs1 * rs2`  |
|     div     | `0000000` |  -  |  -  | `110`  |  -  |    `0110011`    | `rd = rs1 / rs2`  |
|     lsl     | `0000000` |  -  |  -  | `111`  |  -  |    `0110011`    | `rd = rs1 << rs2` |
|     lsr     | `0000001` |  -  |  -  | `000`  |  -  |    `0110011`    | `rd = rs1 >> rs2` |

### I - type инструкции
Формат:

|    imm     |    rs1     |   funct3   |    rd     |  opcode  |
| :--------: | :--------: | :--------: | :-------: | :------: |
| `[31..20]` | `[19..15]` | `[14..12]` | `[11..7]` | `[6..0]` |
|  12 bits   |   5 bits   |   3 bits   |  5 bits   |  7 bits  |

Инструкции и их бинарное представление:

| instruction | imm | rs1 | funct3 | rd  |       opcode       |               description               |
| :---------: | :-: | :-: | :----: | :-: | :----------------: | :-------------------------------------: |
|    addi     |  -  |  -  | `000`  |  -  | `0010011  - 0x13`  |            `rd = rs1 + imm`             |
|    andi     |  -  |  -  | `001`  |  -  |  `0010011 - 0x13`  |            `rd = rs1 & imm`             |
|     ori     |  -  |  -  | `010`  |  -  | ``0010011 - 0x13`` |            `rd = rs1 \| imm`            |
|     lw      |  -  |  -  | `000`  |  -  |  `0000011 - 0x3`   |        `rd = mem[rs1 + offset]`         |
|    jalr     |  -  |  -  | `000`  |  -  |  `1100111 - 0x67`  | `PC = (rs1 + offset) & ~1`, `rd = PC+4` |
### S-type инструкции

Формат:

| imm`[11:5]` |    rs2     |    rs1     |   funct3   | imm`[4:0]` |  opcode  |
| :---------: | :--------: | :--------: | :--------: | :--------: | :------: |
| `[31..25]`  | `[24..20]` | `[19..15]` | `[14..12]` | `[11..7]`  | `[6..0]` |
|   7 bits    |   5 bits   |   5 bits   |   3 bits   |   5 bits   |  7 bits  |

Инструкции и их бинарное представление:

| instruction | imm`[11:5]` | rs2 | rs1 | funct3 | imm`[4:0]` |      opcode      |    description     |
| :---------: | :---------: | :-: | :-: | :----: | :--------: | :--------------: | :----------------: |
|     sw      |      -      |  -  |  -  |  000   |     -      | `0100011 - 0x23` | `[r1 + imm] <- r2` |

### B-type инструкции

Формат:

| imm`[11:0]` |    rs2     |    rs1     |  funct3  |  opcode  |
| :---------: | :--------: | :--------: | :------: | :------: |
| `[31..21]`  | `[19..15]` | `[14..10]` | `[9..7]` | `[6..0]` |
|   12 bits   |   5 bits   |   5 bits   |  3 bits  |  7 bits  |

Инструкции и их бинарное представление:

| instruction | imm`[11:0]` | rs2 | rs1 | funct3 |      opcode      |             description             |
| ----------- | :---------: | :-: | :-: | :----: | :--------------: | :---------------------------------: |
| beq         |      -      |  -  |  -  | `000`  | `1100011 - 0x63` | `branch if r1 == r2, PC ← PC + imm` |
| bne         |      -      |  -  |  -  | `001`  | `1100011 - 0x63` | `branch if r1 ≠ r2, PC ← PC + imm`  |
| bgt         |      -      |  -  |  -  | `010`  | `1100011 - 0x63` | `branch if r1 > r2, PC ← PC + imm`  |
| ble         |      -      |  -  |  -  | `011`  | `1100011 - 0x63` | `branch if r1 ≤ r2, PC ← PC + imm`  |
### U-type инструкции

Формат:

|    imm     |    rd     |  opcode  |
| :--------: | :-------: | :------: |
| `[31..12]` | `[11..7]` | `[6..0]` |
|  20 bits   |  5 bits   |  7 bits  |

Инструкции и их бинарное представление:

| instruction | imm`[31:12]` | rd  |      opcode      |         description          |
| :---------: | :----------: | :-: | :--------------: | :--------------------------: |
|     lui     |      -       |  -  | `0110111 - 0x37` | Load upper immediate to `r1` |

### J-type инструкции

Формат:

| imm`[31:12]` | rd        | opcode   |
| ------------ | --------- | -------- |
| `[31..12]`   | `[11..7]` | `[6..0]` |
| 20 bits      | 5 bits    | 7 bits   |

Инструкции и их бинарное представление:

| instruction | imm`[31:12]` | rd  |      opcode      |          description           |
| :---------: | :----------: | :-: | :--------------: | :----------------------------: |
|     jal     |      -       |  -  | `1101111 - 0x6F` | `PC ← PC + imm`, `r1 ← PC + 4` |
### sys-type
| instruction | operands | opcode (bin) | opcode (hex) |    description     |
| :---------: | :------: | :----------: | :----------: | :----------------: |
|   `halt`    |    –     |  `1111111`   |    `0x7F`    | Custom system/halt |

## Потактовое выполнение

|        Инструкция        | Кол-во тактов |                 Потактовое выполнение                 |
| :----------------------: | :-----------: | :---------------------------------------------------: |
| `add <rd>, <rs1>, <rs2>` |       1       |                   `rs1 + rs2 -> rd`                   |
| `sub <rd>, <rs1>, <rs2>` |       1       |                   `rs1 - rs2 -> rd`                   |
| `mul <rd>, <rs1>, <rs2>` |       1       |                   `rs1 * rs2 -> rd`                   |
| `div <rd>, <rs1>, <rs2>` |       1       |                   `rs1 / rs2 -> rd`                   |
|          `lsl`           |               |                                                       |
|          `lsr`           |               |                                                       |
| `and <rd>, <rs1>, <rs2>` |       1       |                   `rs1 & rs2 -> rd`                   |
| `or <rd>, <rs1>, <rs2>`  |       1       |                  `rs1 \| rs2 -> rd`                   |
| `xor <rd>, <rs1>, <rs2>` |       1       |                   `rs1 ^ rs2 -> rd`                   |
| `addi <rd>, <rs1>, <k>`  |       2       |             `k -> r31`,`rs1 + r31 -> rd`              |
|  `ori <rd>, <rs1>, <k>`  |       2       |             `k -> r31`,`rs1 \| r31 -> rd`             |
|     `jal <rd>, <k>`      |       3       |      `pc + 1 -> rd`,`k -> r31`,`pc + r31 -> pc`       |
| `jalr <rd>, <rs1>, <k>`  |       3       |      `pc + 1 -> rd`,`k -> r31`,`rs1 + r31 -> pc`      |
| `beq <rs1>, <rs2>, <k>`  |       3       | `k -> r31`,`rs1 - rs2 -> NZ`,`if Z then pc + k -> pc` |
| `bne <rs1>, <rs2>, <k>`  |       3       | `k -> r31`,`rs1 - rs2 -> NZ`,`if Z then pc + 1 -> pc` |
| `bgt <rs1>, <rs2>, <k>`  |       3       | `k -> r31`,`rs1 - rs2 -> NZ`,`if N then pc + 1 -> pc` |
| `ble <rs1>, <rs2>, <k>`  |       3       | `k -> r31`,`rs1 - rs2 -> NZ`,`if N then pc + k -> pc` |
|          `halt`          |       1       |                     Stop machine                      |

| Такт | Стадия |        Действие         |
| :--: | :----: | :---------------------: |
| `1`  |  `IF`  | `IPC <- PC, IR <- [PC]` |
| `2`  |  `IF`  |     `PC <- PC + 4`      |
|  …   |   …    |            …            |


| Инструкция | Кол-во тактов | Исполнение |
| :--------: | :-----------: | :--------: |

| `jal <rd>, <k>` |       2       | `PC ← PC + imm`, `r1 ← PC + 4` |


### Структура микрокода

Каждая микрокоманда (`MicroInstruction`) задаёт один такт выполнения инструкции. Ниже приведены поля и их описание:

|    Поле     |       Тип       |       Возможные значения       |                         Назначение                          |
| :---------: | :-------------: | :----------------------------: | :---------------------------------------------------------: |
| `latch_pc`  | `Optional[str]` |  `"inc"`, `"alu"`, `"branch"`  | Управление PC: инкремент, загрузка из ALU, условный переход |
| `latch_ir`  |     `bool`      |        `True` / `False`        |        Загрузить инструкцию из памяти по `PC` в `IR`        |
| `latch_reg` | `Optional[int]` |            `0..31`             |        Номер регистра, в который производится запись        |
| `latch_alu` | `Optional[str]` | `"add"`, `"sub"`, ..., `"lui"` |         ALU-операция, которая должна быть выполнена         |
| `latch_ar`  | `Optional[str]` |               —                |              Зарезервировано (не используется)              |
| `mem_read`  |     `bool`      |        `True` / `False`        |      Считать данные из `data_mem` по адресу `ALU_OUT`       |
| `mem_write` |     `bool`      |        `True` / `False`        |      Записать данные в `data_mem` по адресу `ALU_OUT`       |
| `set_flags` |     `bool`      |        `True` / `False`        |     Установить флаги `Z`, `N` на основе результата ALU      |
| `next_mpc`  | `Optional[int]` |       адрес микрокоманды       |        Адрес следующей микрокоманды в микропрограмме        |
|  `jump_if`  | `Optional[str]` | `"Z"`, `"NZ"`, `"GT"`, `"LE"`  |         Условие перехода (для `latch_pc="branch"`)          |
|   `halt`    |     `bool`      |        `True` / `False`        |                Остановить выполнение машины                 |

#### Начальные микрокоманды

| MPC  | Комментарий       |                         Описание                          |
| ---- | ----------------- | :-------------------------------------------------------: |
| 0    | `FETCH`           |     Загрузка команды из `instr_mem` в `IR`, `PC += 4`     |
| 1    | `DECODE`          |            Переход к общей точке декодирования            |
| 1000 | `DECODE DISPATCH` | Поиск нужной микропрограммы по `(opcode, funct3, funct7)` |
