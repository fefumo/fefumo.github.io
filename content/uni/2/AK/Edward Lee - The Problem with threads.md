---
tags:
  - uni
---
В своих рассуждениях на тему многопоточности Эдвард Ли придерживается отрицательного мнения в сторону наличия её в современном (на момент написания эссе – 2006г.) коде. Кратко приведу факты, которые он приводит в качестве доказательства своей теории.
 - Людям сложнее думать и рассуждать о параллельном коде, чем о последовательном
 - Главная проблема с математической точки зрения – недетерминированность в вычислениях, так как невозможно определить эквивалентность двух состояний процессов: “We conclude that with threads, there is no useful theory of equivalence”
 - Даже тестирование может не решить все проблемы в многопоточном коде.
Затем, он рассказывает о “компромиссах”, которые уже существуют, в виде C-like языков, но к сожалению все еще являются эзотерикой для большинства, а так же не решают проблему с deadlock-ами. 

Главная альтернатива, которую предлагает автор: он приводит в пример простейший паттерн программирования, Observer pattern, у которого есть очевидные проблемы с мультипоточностью. Дабы их решить, он предоставляет несколько вариаций детерминированного кода с помощью некоторого “Директора” (Rendevouz/PN Director), который следит за процессами и Merge Block’а — единственной частью программы, в которой есть недетерминированность. И так как в ней отсутвует зацикленность, то и пропадает проблема deadlock’ов. К сожалению, я не могу опровергнуть или доказать полезность его слов, так как не могу протестриовать эту задумку в реальности из чего и следует моё общее мнение об этой статье.

Данная статья показалась мне странноватой в том плане, что даже когда он привел пример с “решением”, он не показал реальных use-case’ов и не продемонстрировал код который будет исполнять задумку. Что же касается общих мыслей, то спустя почти двадцать лет люди все еще используют параллельные процессы и уживаются друг с другом, так что тейк Эдварда про истребление потоков из программирования в угоду надёжности и предсказуемости — “If we expect concurrent programming to be mainstream, and if we demand reliability and predictability from programs, then we must discard threads as a programming model” — оказался неверным на практике.

Я считаю, что тема параллельного программирования очень обширна и быть радикальным в своих убеждениях кажется мне неверным поступком. Программирование, как дисциплина, учит нас использовать правильные инструменты для разных задач, так что использование многопоточнсти ровно как может быть оправданным решением, ускоряющим производительность, так и критической ошибкой, повлёкшей за собой множество проблем, ведь в зависимости от ситуации можно было использовать, скажем, асинхронность. Всё зависит от поставленной задачи и условий, в которых мы её решаем. Так что главное, как по мне, находить практичные решения и не бояться пробовать что-то новое, а также не отрицать существующих методологий/принципов/инструментов, ведь если они существуют, значит скорее всего на то были причины.