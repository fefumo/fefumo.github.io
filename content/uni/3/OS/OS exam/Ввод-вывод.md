#uni
#prog
# Блочный ввод-вывод
### Типы
Программируеиый ввод-вывод
- Процессор непосредственно управляет периферийным устройством через его шину и регистры
- … или контроллер, который подключается к шине и имеет набор управляющих регистров
Ввод-вывод с использованием прерываний
- в контроллере добавляются прерывания, исключая ожидания
Прямой доступ к памяти (direct memory access)
- в контроллере добавляются регистры и счетчики для обеспечения переноса области буфера в контроллере в область памяти
- Контроллер превращается в отдельный вычислительный модуль (канал ввода-вывода) с процессором и системой команд
- В канал ввода-вывода добавляется доп. оборудование и микропрограммы и контроллер становится отдельным вычислительным устройством  полностью берущим на себя управление вводом-выводом с группой устройств (процессор ввода-вывода)

### Логическая структура ввода-вывода
Процесс (локальное устройство) имеет логический модуль ввода-вывода, который он “дёргает” со стороны операционной системы, а дальше ядро должно организовать определенную логику вокруг вызова.
Локальное устройство/сетевой обмен/файловый обмен.

### Буферизация ввода-вывода
Типы устройств бывают разные. ОС может считать ограниченную информацию. Для блочных устройств нужно решить: надо ли буферизировать данные и зачем?
- Direct IO (без буферизации):
Пользовательская программа запросила у ядра кусок файла, ядро превратило этот кусок в блок с номером на жестком диске, после этого ядро запросило эту информацию у драйвера, тот подготовил всё,  и при помощи дма в пользовательское АП записалось. Из минусов, может быть дедлок, т.к. пользовательское АП улетело в своп, пока ядро доставало данные.
- Одиночная буферизация
- Двойная буферизация
- Кольцевая буферизация

### Диски
На слайде: жёсткий диск. У него есть несколько “блинов”, они вращаются с какой то постоянной скоростью, головка идёт между дорожками, дорожка разбита на сектора. Есть разные интерфейсы: IDE, SATA, SCSI, SAS interfaces

SSD (solid state disk) — SATA, SAS, NVMe intrafaces

Жёсткие диски лучше справляются с последовательным чтением. Если начинается случайное обращение в любое место диска, то скорость обращения к данным сильно уменьшается

- Ожидание в очереди (на стороне ОС)
- Ожидание канала
- Seek (поиск)
- Rotation delay (время оборота)
- Перадача данных

Формула рассчёта времени доступа будет как раз сумма этих факторов.

#### Дисковое планирование 
FIFO — “справедливый метод”
- Все процессы получают одинаковый доступ к диску
- Выгоден для небольшого потока запросов, на большом превращается в случайный доступ (большие издержки)
PRI —  на основе от приоритета процесса
- Выгоден с точки зрения ОС (см. Feedback) для коротких заданий, длинным плохо.
LIFO — Использует преимущества локальности даннхы
- Хороша для транзакционных систем
> А если учитывать при планировании текущее состояние диска ?

SSTF — Shortest Service Time First (Минимизация времени поиска)
SCAN (elevator algorithm) — Ездим туда сюда по диску и обслуживаем запросы
C-SCAN — Ездим по диску во время операций в одну сторону, быстрый возврат
N-step-SCAN — разделяет очередь  на подочереди длинной N …
FCSCAN — две подочереди, пока одна обрабатывается, вторая заполняется.

#### Ввод-вывод  в SVR4
Если запросы идут из файловой подсистемы, то они буферизируются. Дальше они идут в символьные либо блочные устройства, затем в их драйвера

Для блочных там есть “Буферный кэш” на основе хэш-таблицы и free list. В хэш таблице мы находим нужные буферы. Когда памяти не хватает, то используется замещающий алгоритм LRU.

